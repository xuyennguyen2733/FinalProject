#version 410 core

layout(quads, equal_spacing, ccw) in;

//uniform sampler2D normalMap;
//uniform sampler2D dispMap;

//in vec2 txc[];
//in mat3 mn[];
//in mat4 mvp[];
//in vec3 l[];
//in vec3 n[];
//in vec3 pos[];
//in vec4 vw[];
in vec2 txc[];


in DATA{
    vec2 texCoord;
    mat3 outMN;
    mat4 outMVP;
    vec3 outLight;
    vec3 outNorms;
    vec3 outPos;
    vec4 outView;
} data_in[];

out DATA{
    vec2 texCoord;
    mat3 outMN;
    mat4 outMVP;
    vec3 outLight;
    vec3 outNorms;
    vec3 outPos;
    vec4 outView;
} data_out;

out vec2 outTexCoord;


void main() {
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;
    /*
    //vec4 pos0 = gl_in[0].gl_Position;
    vec4 pos1 = gl_in[1].gl_Position;
    vec4 pos2 = gl_in[2].gl_Position;
    vec4 pos3 = gl_in[3].gl_Position;

    vec4 leftPos = mix(pos3, pos1, v);
    vec4 rightPos = mix(pos2, pos0, v);
    vec4 position = mix(leftPos, rightPos, u);

    //vec2 tex0 = txc[0];
    //vec2 tex1 = txc[1];
    //vec2 tex2 = txc[2];
    //vec2 tex3 = txc[3];

    vec2 tex0 = data_in[0].texCoord;
    vec2 tex1 = data_in[1].texCoord;
    vec2 tex2 = data_in[2].texCoord;
    vec2 tex3 = data_in[3].texCoord;

    vec2 leftTex = tex3 + v * (tex1 - tex3);
    vec2 rightTex = tex2 + v * (tex0 - tex2);
    vec2 tex = leftTex + u * (rightTex - leftTex);
    //tex.x = pos.x/50.0f+0.5;
    //tex.y = pos.y/50.0f+0.5;

    mat3 matrixNormal = mn[0];
    //vec4 displacement = texture(dispMap, tex);
    //vec4 n = vec4(0,0,1,0) * displacement;
    float scale = 0.1f;
    
    //gl_Position = pos + n * scale;
    //pos.z += displacement.x;
    //gl_Position = mvp[0] * pos;
    
    //gl_Position.z = gl_Position.z + displacement * 0.5;
    */
    
    //gl_Position = position;
    //data_out.texCoord = txc[0];
    //data_out.outMN = mn[0];
    //data_out.outMVP = mvp[0];
    //data_out.outLight = l[0];
    //data_out.outNorms = n[0];
    //data_out.outPos = pos[0];
    //data_out.outView = vw[0];

    vec4 pos0 = gl_in[0].gl_Position;
    vec4 pos1 = gl_in[1].gl_Position;
    vec4 pos2 = gl_in[2].gl_Position;
    vec4 pos3 = gl_in[3].gl_Position;

    vec4 leftPos = mix(pos3, pos1, v);
    vec4 rightPos = mix(pos2, pos0, v);
    vec4 position = mix(leftPos, rightPos, u);

    vec2 tex0 = txc[0];
    vec2 tex1 = txc[1];
    vec2 tex2 = txc[2];
    vec2 tex3 = txc[3];

    vec2 leftTex = tex3 + v * (tex1 - tex3);
    vec2 rightTex = tex2 + v * (tex0 - tex2);
    vec2 tex = leftTex + u * (rightTex - leftTex);

    gl_Position = position;

    data_out.texCoord = tex;
    data_out.outMN = data_in[0].outMN;
    data_out.outMVP = data_in[0].outMVP;
    data_out.outLight = data_in[0].outLight;
    data_out.outNorms = data_in[0].outNorms;
    data_out.outPos = data_in[0].outPos;
    data_out.outView = data_in[0].outView;
    outTexCoord = tex;

}